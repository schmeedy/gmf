/******************************************************************************
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    IBM Corporation - initial API and implementation 
 ****************************************************************************/
package org.eclipse.gmf.tests.runtime.emf.core.internal.listener;

import java.util.List;

import org.eclipse.emf.common.notify.Notification;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.examples.extlibrary.EXTLibraryPackage;
import org.eclipse.emf.examples.extlibrary.Library;
import org.eclipse.emf.transaction.Transaction;
import org.eclipse.gmf.runtime.emf.core.EventTypes;
import org.eclipse.gmf.runtime.emf.core.edit.MFilter;
import org.eclipse.gmf.runtime.emf.core.edit.MListener;
import org.eclipse.gmf.runtime.emf.core.edit.MRunnable;
import org.eclipse.gmf.runtime.emf.core.edit.MSemProcProvider;
import org.eclipse.gmf.runtime.emf.core.edit.MUndoInterval;
import org.eclipse.gmf.runtime.emf.core.exceptions.MSLActionAbandonedException;
import org.eclipse.gmf.tests.runtime.emf.core.BaseCoreTests;


public class MSemProcProviderTests
	extends BaseCoreTests {
	/**
	 * Tests whether the Action Completion Notification is fired.
	 */
	public void testActionCompletionNotification() {
		final boolean[] isActionCompletedNotification = new boolean[2];
		isActionCompletedNotification[0] = false;
		isActionCompletedNotification[1] = false;
		MSemProcProvider testSemProcProvider = new MSemProcProvider() {
			public void onEvent(List events) {
				if(isActionCompletedNotification[1] != true)
					isActionCompletedNotification[0] = true;
			};
		};
		
		MListener regularListener = new MListener() {
			public void onEvent(List events) {
				// only set true if the 
				if(isActionCompletedNotification[0] == true)
					isActionCompletedNotification[1] = true;
			}
		};
		
		/**
		 * Filter definition to restrict notifications to those generated by <code>MUndoInterval</code>s
		 */
		MFilter notifierTypeFilter = new MFilter.NotifierType(Transaction.class, true);
		MFilter notUndoIntervalFilter = new MFilter.Not(new MFilter.NotifierType(MUndoInterval.class, true));
		
		/**
		 * Filter definition to restrict notifications to <code>CREATE</code> notifications.
		 */
		MFilter eventTypeFilter = new MFilter.EventType(EventTypes.CREATE);
		
		/**
		 * Composite filter to restrict notifications to <code>CREATE</code>s on <code>MUndoInterval</code>s
		 */
		MFilter fullFilter = new MFilter.And(new MFilter.And(notifierTypeFilter, notUndoIntervalFilter) , eventTypeFilter);
		
		testSemProcProvider.setFilter(fullFilter);
		regularListener.setFilter(fullFilter);
		
		regularListener.startListening();
		testSemProcProvider.startListening();
		
		domain.runInUndoInterval(new Runnable() {
			public void run() {
				try {
					domain.runAsWrite(new MRunnable() {
						public Object run() {
							root.setName("OPL"); //$NON-NLS-1$
							return null;
						}
					});
				} catch (MSLActionAbandonedException e) {
					fail(e.getLocalizedMessage());
				}
			}
		});
		testSemProcProvider.stopListening();
		regularListener.stopListening();

		assertTrue(isActionCompletedNotification[0] && isActionCompletedNotification[1]);
	}
	
	/**
	 * Tests whether other notifications are fired to the sem proc provider,
	 * and these ones are before other listeners.
	 */
	public void testOtherNotifications() {
		final boolean[] isNameChangedNotification = new boolean[2];
		isNameChangedNotification[0] = false;
		isNameChangedNotification[1] = false;
		
		MSemProcProvider testSemProcProvider = new MSemProcProvider() {
			public void onEvent(List events) {
				if(isNameChangedNotification[1] != true)
					isNameChangedNotification[0] = true;
			};
		};
		
		MListener regularListener = new MListener() {
			public void onEvent(List events) {
				// only set true if the 
				if(isNameChangedNotification[0] == true)
					isNameChangedNotification[1] = true;
			}
		};
		
		MFilter filter = new MFilter() {
			public boolean matches(Notification event) {
				Object notifier = event.getNotifier();
				if(notifier instanceof Library) {
					EStructuralFeature feature = (EStructuralFeature)event.getFeature();
					if(feature == EXTLibraryPackage.eINSTANCE.getLibrary_Name()) {
						String newName = event.getNewStringValue();
						if(newName.equals("OPL")) //$NON-NLS-1$
							return true;
					}
				}
				return false;
			}
		};
		regularListener.setFilter(filter);
		testSemProcProvider.setFilter(filter);
		
		regularListener.startListening();
		testSemProcProvider.startListening();
		domain.runInUndoInterval(new Runnable() {
			public void run() {
				try {
					domain.runAsWrite(new MRunnable() {
						public Object run() {
							root.setName("OPL"); //$NON-NLS-1$
							return null;
						}
					});
				} catch (MSLActionAbandonedException e) {
					fail(e.getLocalizedMessage());
				}
			}
		});
		testSemProcProvider.stopListening();
		regularListener.stopListening();
		assertTrue(isNameChangedNotification[0] && isNameChangedNotification[1]);
	}
}
